## PROTOCOL

Протокол довольно простой и имеет достаточно абстрактный вид.
Но прежде чем переходить к его описанию, нужно ознакомиться с типами данных, которые используются в протоколе.

### Типы данных

Под стандартным типом данных мы понимаем любой тип, который описывается форматом [JSON](https://www.json.org/).
Помимо стандартных типов данных в протоколе используются дополнительные типы, которые выражаются через стандартные, но имеют определённый формат.

`Timestamp` - [Unix-время](https://en.wikipedia.org/wiki/Unix_time) **в миллисекундах**. Соответствует стандартному типу `Int`, хранимому в `ByteString` **(strict)**. Данный формат времени настоятельно рекомендуется использовать в разрабатываемых компонентах.

`Hash` - hash-сумма от строки по методу [SHA-1](https://en.wikipedia.org/wiki/SHA-1). Соответствует стандартному типу `ByteString` **(strict)**.

`JSON` - любой валидный [JSON](https://www.json.org/) в виде `ByteString` **(strict)**.

### Общий вид сообщения

Общие поля для всех видов коммуникационных сообщений следующие:

`tag :: ByteString` – Тэг (заголовок) сообщения. Содержит краткую информацию о содержимом и формируется на основании наличия или отсутствия тех или иных полей.

`content`
  * `id :: Hash` - идентификатор сообщения, вычисляется как hash-сумма от строки `"<creator>:<created_at>:<spec>"`, где `<поле>` заполняется значением из соответствующего поля;
  * `pid :: Hash` - идентификатор сообщения, который является родительским для данного, содержит поле `id` родительского сообщения. Если сообщение не имеет "родительского", это поле заполяется пустой строкой;
  * `creator :: ByteString` **(strict)** - идентификатор пользователя/сервиса/система, который породил данное сообщение;
  * `created_at :: Timestamp` - Unix-время создания сообщения;
  * `expires_at :: Timestamp` - Unix-время того момента, когда данное сообщение станет неактуальным для системы. Если сообщение не имеет "срока годности", это поле заполняется нулём;
  * `spec :: ByteString` **(strict)** - спецификация сообщения в следующем формате: `project_message`, где `project` и `message` могут содержать следующие символы: **маленькие** латинские буквы `a-z`, цифры `0-9`, дефис `-`.
  * `encoding :: ByteString` **(strict)** - кодировка, в которой хранится специфичное поле сообщения (JSON или MessagePack на данный момент).

Таким образом, сообщение на коммуникационном уровне имеет вид

```
tag :: ByteString

content:
{
  id         :: Hash,
  pid        :: Hash,
  creator    :: ByteString,
  created_at :: Timestamp,
  expires_at :: Timestamp,
  spec       :: ByteString,
  encoding   :: ByteString,
  type       :: String,
  data       :: ByteString
}
```

#### Чем важно поле spec?

Поле `spec` важно по следующим причинам:

* оно определяет то, что будет находиться внутри передаваемых сообщений;
* если используется подход вопрос-ответ вместе с контроллером, то именно поле spec будет определять контроллер, который будет распределять задачи между компонентами;
* **центральное место (Scheduler) не будет пропускать сообщения в очередь, если поле spec сообщения не зарегистрировано (читай "не задокументировано") в системе**. Данное правило позволяет избежать появления в системе сообщений, на которых нет документации.

### Заголовок сообщения

У каждого сообщения есть заголовок – информация, видимая вне зависимости от применения шифрования к содержимому сообщения. 
Заголовок нужен для того, чтобы не читая (или не имея возможности прочитать) сообщение определить, от кого оно, какого оно типа, интересно ли оно получившему его компоненту и т.д. 

Заголовок содержит следующие поля:
* `message_type :: ByteString` **(strict)** – тип сообщения. Определяется наличием или отсутствием тех или иных полей помимо общих (см. [тело сообщения](#Тело-сообщения)). 
* `spec :: ByteString` **(strict)** – спецификация сообщения.
* `id :: Hash` – идентификатор сообщения.
* `pid :: Hash | null` – идентификатор родительского сообщения.
* `creator :: ByteString` **(strict)** – идентификатор пользователя/сервиса/система, который породил данное сообщение.

Заголовок – это строка (`ByteString`). Вышеописанные поля следует конвертировать в строку через символ ':' – `"<message_type>:<spec>:<id>:<pid>:<creator>"`. Всюду ниже заголовок является значением поля `tag`.

Если поле pid отсутствует, отделяющие его двоеточия всё равно следует писать: `"<message_type>:<spec>:<id>::<creator>"`. Это необходимо для возможности считывания всех полей по разделителю.

### Тело сообщения
#### Вопрос-ответ

Сообщения вида вопрос-ответ предназначены для постановки задачи компонентам в системе и получение данных в результате выполнения поставленной задачи.
Сообщение с постановкой задачи имеет следующее дополнительное поле:

* `config :: ByteString` - описание конфигурации задачи в формате JSON или MessagePack. Это поле определяет тип сообщения: `message_type` из заголовка для него равен `config`.

Таким образом, сообщение-вопрос будет иметь вид

```
tag: "config:<spec>:<id>:<pid>:<creator>"

content:
{
  id         :: Hash,
  pid        :: Hash | null,
  creator    :: ByteString,
  created_at :: Timestamp,
  expires_at :: Timestamp,
  spec       :: ByteString,
  config     :: ByteString,
  encoding   :: ByteString
}
```

Сообщение с результатом имеет следующие поля:

* `result :: ByteString | null` - результат успешного выполнения задачи (в случае ошибки оставляется пустым);
* `error :: ByteString | null` - сообщение с ошибкой в случае невыполнения задачи (в случае успешного выполнения оставляется пустым).

Наличие одного из этих полей определит тип сообщения в заголовке как `result` или `error` соответственно.
Наличие обоих полей одновременно невозможно (контракт).

Сообщение-ответ в случае "успеха" будет иметь вид

```
tag: "result:<spec>:<id>:<pid>:<creator>"

content:
{
  id         :: Hash,
  pid        :: Hash | null,
  creator    :: ByteString,
  created_at :: Timestamp,
  expires_at :: Timestamp,
  spec       :: ByteString,
  result     :: ByteString,
  encoding   :: ByteString
}
```

А сообщение-ответ в случае "неуспеха" будет иметь вид

```
tag: "error:<spec>:<id>:<pid>:<creator>"

content:
{
  id         :: Hash,
  pid        :: Hash | null,
  creator    :: ByteString,
  created_at :: Timestamp,
  expires_at :: Timestamp,
  spec       :: ByteString,
  error      :: ByteString,
  encoding   :: ByteString
}
```

Для сообщений типа `вопрос-ответ` есть следующие правила:
* для сообщения-вопроса может не быть сообщения-ответа;
* если для сообщения-вопроса есть сообщение-ответ, тогда их поле `spec` совпадает.

#### Произвольные данные

Сообщения c произвольными данными описывает, как ни странно, произвольные данные, которые не обязаны быть ответом на какой-либо вопрос.
Сообщение такого типа имеет только одно дополнительное поле:

* `data :: ByteString` - данные, которые соответствуют указанному полю `spec`. Наличие этого поля определяет тип сообщения в заголовке как `data`.

Полный вид сообщения:

```
tag: "data:<spec>:<id>:<pid>:<creator>"

content:
{
  id         :: Hash,
  pid        :: Hash | null,
  creator    :: ByteString,
  created_at :: Timestamp,
  expires_at :: Timestamp,
  spec       :: ByteString,
  data       :: ByteString,
  encoding   :: ByteString
}
```

## Реализация протокола

### Вопрос-ответ

Алгоритм реализации протокола [вопрос-ответ](#Вопрос-ответ) со стороны компонента, отправляющего вопрос:
1. Убедиться в том, что компонент, который посылает вопрос, подключён к Scheduler'у по следующим каналам:
    * по [каналу передачи задач](../README.md#Взаимодействие-scheduler-component) на отправку задач через [PUSH](../README.md#push-pull);
    * по [каналу получения данных](../README.md#Взаимодействие-scheduler-component) на получение данных через [SUB](../README.md#pub-sub);
2. Сформировать [сообщение-вопрос](#Вопрос-ответ) к вызываемому компоненту;
3. Сохранить **id** сообщения-вопроса;
4. Отправить сообщение-вопрос через [PUSH](../README.md#push-pull) Scheduler'у;
5. Ждать от Scheduler'а через [SUB](../README.md#pub-sub) [сообщение-ответ](#Вопрос-ответ), **pid** которого совпадает с **id**, сохранённом на 3 шаге;
6. Получить [сообщение-ответ](#Вопрос-ответ) по подписке через [SUB](../README.md#pub-sub).

Алгоритм реализации протокола [вопрос-ответ](#Вопрос-ответ) со стороны компонента, отправляющего ответ:
1. Убедиться в том, что компонент, который принимает вопрос и отправляет последующий ответ, подключён к Scheduler'у по следующим каналам:
    * по [каналу передачи данных](../README.md#Взаимодействие-scheduler-component) на отправку данных через [PUSH](../README.md#push-pull);
    * по [каналу получения задач](../README.md#Взаимодействие-scheduler-component) на получение задач:
      * либо напрямую через [SUB](../README.md#pub-sub);
      * либо посредством [контроллера](../README.md#Что-такое-контроллер), забирая от того задачи через [PULL](../README.md#push-pull);
2. Обеспечить данному компоненту возможность получать задачи, [поле **spec**](#Чем-важно-поле-spec) которых совпадает с полем **spec** ожидаемого вопроса;
3. Получить вопрос и сохранить его **id**;
4. Сформировать ответ на полученный вопрос, заполнив поле **pid** тем **id**, который был сохранён на 3 шаге;
5. Отправить в Scheduler'а через [PUSH](../README.md#push-pull) сформированный на предыдущем шаге ответ.

### Произвольные данные

Алгоритм отправки [произвольных данных](#Произвольные-данные):
1. Убедиться в том, что компонент, отправляющий данные, подключён к Scheduler'у по [каналу передачи данных](../README.md#Взаимодействие-scheduler-component) на отправку данных через [PUSH](../README.md#push-pull);
2. Сформировать сообщение с [данными](#Произвольные-данные);
3. Отправить в Scheduler'а через [PUSH](../README.md#push-pull) сформированное на предыдущем шаге сообщение.

Алгоритм получения [произвольных данных](#Произвольные-данные):
1. Убедиться в том, что компонент, который посылает вопрос, подключён к Scheduler'у по [каналу получения данных](../README.md#Взаимодействие-scheduler-component) на получение данных через [SUB](../README.md#pub-sub);
2. Ждать от Scheduler'а через [SUB](../README.md#pub-sub) [данные](#Произвольные-данные), [поле **spec**](#Чем-важно-поле-spec) которых совпадает с полем **spec** ожидаемых данных;
3. Получить данные по подписке через [SUB](../README.md#pub-sub).
