## Протокол

Протокол системы MoniQue - это формат сообщений и набор правил, которые позволяют компонентам общаться друг с другом и понимать друг друга.
Совершенно очевидно, что легче и правильней всего будет взять какой-то существующий формат и, используя его, договориться (или декларировать) о том, какие там будут поля и что они будут значить.

В MoniQue версии 2 таким форматом был [JSON](https://www.json.org/json-en.html).
Это хороший и удобный формат, но он не поддерживает бинарные данные и имеет накладные расходы на служебные символы.
Поэтому в MoniQue версии 3 нами был выбран другой формат, о котором скажем пару слов.

### MessagePack

[MessagePack](https://msgpack.org/) - бинарный формат, который по структуре очень похож на JSON. 
Этакий бинарный JSON.
К примеру, вот такой JSON
```
{"compact":true,"schema":0, "message":"this is message"}
```
в формате MessagePack будет выглядеть следующим образом (как последовательность [HEX](https://en.wikipedia.org/wiki/Hexadecimal) символов):
```
83 a7 63 6f 6d 70 61 63 74 c3 a6 73 63 68 65 6d 61 00 a7 6d 65 73 73 61 67 65 af 74 68 69 73 20 69 73 20 6d 65 73 73 61 67 65
```
или как последовательность символов в [Base64](https://en.wikipedia.org/wiki/Base64):
```
g6djb21wYWN0w6ZzY2hlbWEAp21lc3NhZ2WvdGhpcyBpcyBtZXNzYWdl
```
Подробнее можно узнать на сайте этого формата и в его [спецификации](https://github.com/msgpack/msgpack/blob/master/spec.md).

На самом деле, MessagePack практически всегда можно перевести в JSON и обратно.
Поэтому при дальнейшем описании протокола мы будем пользоваться форматом, который будет походить на JSON, при этом подразумевая, что в системе это сообщение будет жить в формате MessagePack.

В MessagePack есть следующие стандартные типы: 
  * nil (пустой); 
  * bool (булевский);
  * int (целочисленный);
  * float (с плавающей точкой);
  * str (строковый);
  * bin (бинарный);
  * array (массив);
  * map ("объект");
  * ext (дополнительные расширения).
  
Поле с типом мы будем обозначать так: `поле :: тип`.

Коль скоро мы договорились об основном формате, настало время договориться о часто используемых обозначениях.

### Обозначения

Помимо стандартных типов, которые описаны в формате MessagePack, мы заведём дополнительные, которые будут выражаться через стандартные, но иметь какой-то определённый смысл.

**timestamp = int** - [Unix-время](https://en.wikipedia.org/wiki/Unix_time) **в миллисекундах**. Данный формат времени настоятельно рекомендуется использовать в разрабатываемых компонентах.

### Формат сообщения

Сообщение имеет тип `map` с ключом типа `str`. В сообщении должны присутствовать следующие поля:

```
{ id         :: str
, pid        :: str
, creator    :: str
, created_at :: timestamp
, expires_at :: timestamp
, spec       :: str
, type       :: str
, data       :: bin
, encrypted  :: bool
, signature  :: bin
}
```
А теперь подробнее про каждое поле.

#### id

Идентификатор сообщения, формируется как текущее как рандомные 40 символов из алфавита `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`.
> Пример: `Ndj2FKSzNv42IOxGPJyz5SmiT9VxYrLAKTUv9j4s`.

Необходимо убедиться, что для генерации рандомных чисел в используемом языке реализован надёжный генератор псевдо-случайных чисел.

#### pid

Идентификатор сообщения, который является родительским для данного, содержит поле `id` родительского сообщения. 
Если сообщение не имеет "родительского", это поле заполняется пустой строкой.
Родительсткое сообщение определяется с помощью логики.
> Пример: компонент `A` решил что-нибудь спросить у компонента `B`, отправив сообщение `x`.
> Компонент `B`, отправляя в ответ компоненту `A` сообщение `y`, должен в поле `pid` сообщения `y` вставить поле `id` из сообщения `x`.

Это один из возможных примеров (но не единственный) использования поля `pid`.

#### creator

Идентификатор пользователя/сервиса/компонента, который породил данное сообщение.
До появления сервиса авторизации данное поле может заполняться произвольно.
Потом оно будет специфицировано сервисом авторизации.

#### created_at

Unix-время создания сообщения в миллисекундах.

#### expires_at

Unix-время того момента, когда данное сообщение станет неактуальным для системы.
> Пример: пусть компонент `A` запрашивает у компонента `B` какую-либо информацию с помощью сообщения `x`, в котором указано "истекающее" время (к примеру, 1525427613253).
> Если `B` не вернёт ответ раньше 1525427613253, то компоненту `A` ответ будет уже неважен.

Если сообщение не имеет "срока годности" (то есть оно будет актуально всегда), это поле заполняется нулём.

#### spec

Спецификация сообщения в следующем формате: `project_message`, где `project` и `message` могут содержать следующие символы: **маленькие** латинские буквы `a-z`, цифры `0-9`, дефис `-`.
Под проектом мы понимаем то, что может идеологически или функционально объединенять сообщения в одну группу.
> Пример: в проекте-сервисе `ss` (Semantic System) есть сообщение, которое служит для передачи аннотации и называется `ig-annotate`.
> Тогда поле `spec` для такого сообщения будет `ss_ig-annotate`.
> В той же сервисе может быть сообщение, которое служить для запуска минимизации. 
> Тогда поле `spec` для него будет `ss_minimize`.

Данное поле очень важно по следующим причинам (некоторые определения будут даны позже):
  * оно определяет то, что будет находиться внутри передаваемых сообщений;
  * для распределения задач между однотипными компонентами может использоваться контроллер, который будет определятся по данному полю;
  * **центральное место (Scheduler) не будет пропускать сообщения в очередь, если поле spec сообщения не зарегистрировано (читай "не задокументировано") в системе**. Данное правило позволяет избежать появления в системе сообщений, на которых нет документации.

#### type

Тип сообщения.
В MoniQue всего 4 типа сообщений: 
  1. `config` - сообщение с какой-либо конфигурацией. Обычно используется для того, чтобы один компонент мог поставить какую-либо задачу другому компоненту;
  2. `result` - сообщение с каким-либо результатом. Обычно является ответом на сообщение с типом `config`;
  3. `error` - сообщение с ошибкой. Может быть как ответом на сообщение с типом `config` при неудачном выполнении задачи, а может самостоятельно порождаться каким-либо компонентом. Подробнее про данный тип читай [тут](Error.md);
  4. `data` - сообщение с произвольными данными.
Вполне может оказаться так, что сообщения могут иметь одинаковое поле `spec`, но различное поле `type`.
> Пример: сообщение со `spec = ss_ig-annotate` и `type = config` является запросом на аннотирование.
> А сообщение со `spec = ss_ig-annotate` и `type = result` содержит в себе результат аннотирования.

#### data

Данные, которые содержатся в сообщении.
Несложно заметить, все остальные поля являются служебными и являются некоторым описанием данных.
В то время как именно поле `data` несёт в себе содержательную информацию.

Как уже упоминалось, самы данные должны быть сформированы в MessagePack.

Как формируется поле `data`:
  1. данные в формате MessagePack кодируются в бинарное представление;
  2. (опционально) получившаяся бинарная строка шифруется открытым ключом.
  
Как считывается поле `data`:
  1. (опционально) бинарная строка дешифруется закрытым ключом;
  2. получившаяся бинарная строка декодируется в формат MessagePack.
  
Комментарий к опциональным полям: на текущий момент сервис с шифрованием, распределением прав и ключей находится в стадии разработки.
Как только он будет разработан, в данном месте будет приведена ссылка на его документацию и использование.

Хотя видимых ограничений на передачу сообщений размера (2^32)-1 байт (4 Gb) нет, разработчики MoniQue настоятельно рекомендуют пересылать данные не более 1 Mb.

#### encrypted

Флаг, который указывает на то, были ли данные при записи зашифрованы или нет.
По этому флагу можно судить о необходимости шагов шифрования/дешифрования при работе с полем `data`.

#### signature

Подпись, которая верифицирует отправителя сообщения.
Имеет бинарный формат.
Если сообщение не подписывается, то поле заполняется пустой бинарной строкой.

То, по какому правилу нужно подписывать сообщение, будет описано позже, когда сервис с ключами шифрования будет разработан.

### Заголовок сообщения

В системе MoniQue сообщение никогда не путешествует поодиночке, только в компании с заголовком (или тэгом, англ. Tag).
Аналогия: при отправлении письма по электронной почте всегда указывается заголовок (тема) письма.
Точно также, когда сообщение отправляется в систему MoniQue, оно должно предваряться заголовком, который устроен определённым образом.

Для каждого сообщения заголовок формируется следующим образом: 
  1. нужно взять поля `type`, `spec`, `id`, `pid` и `creator` из сообщения;
  2. сделать одну строку из этих полей, разделив их двоеточием.
  
Заголовок сообщения готов.
Нужно заметить, что если поле `pid` пусто (у сообщения нет родительского), то в заголовке будут идти два двоеточия подряд, и это нормально.

> Пример: для сообщения с соответствующими полями `data`, `example_radio`, `1529356853606928029`, `` (нет родительского сообщения) и `0000-0000-0000-radio-speaker` заголовок
> сообщения будет иметь вид `data:example_radio:1529356853606928029::0000-0000-0000-radio-speaker`.

Заголовок сообщения прежде всего предназначен для того, чтобы без распаковки всего сообщения понимать, должно ли оно обрабатываться или его можно пропустить.




